[{"C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\index.js":"1","C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\App.js":"2","C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\reportWebVitals.js":"3"},{"size":747,"mtime":1648765005684,"results":"4","hashOfConfig":"5"},{"size":21064,"mtime":1648765467322,"results":"6","hashOfConfig":"5"},{"size":362,"mtime":1648764409464,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"149nw2i",{"filePath":"11","messages":"12","suppressedMessages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\index.js",[],[],"C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\App.js",["18","19","20","21","22","23","24","25","26","27","28","29","30","31","32"],[],"import React, { useEffect, useState } from 'react';\nimport './App.css';\n\n// Render each post\nfunction renderPost(post){\n  const { data: { title, url, author, id } } = post\n  const authorUrl = `https://www.reddit.com/u/${author}`\n\n  return (\n    <div className=\"reddit_widget__post\" key={id}>\n      <div className=\"reddit_widget__posted_by\">\n        posted by <a href={authorUrl} className=\"reddit_widget__posted_by\" target=\"_blank\" rel=\"noopener noreferrer\">u/{author}</a>\n      </div>\n      <a href={url} className=\"reddit_widget__title\" target=\"_blank\" rel=\"noopener noreferrer\">{title}</a>\n    </div>\n  )\n}\n\n// Filter, since reddit always returns stickied posts up top\nfunction nonStickiedOnly(post){\n  return !post.data.stickied\n}\n\nfunction App({ domElement }) {\n    //these happen once no matter what; they will not run again\n    const [username, setUsername] = useState(\"\");\n    const [orderLink, setOrderLink] = useState(\"\");\n    const [status, setStatus] = useState(\"loading\");\n    const [timeSlot, setTimeSlot] = useState(\"\");\n    const [imgUrl, setImgUrl] = useState(\"\");\n    const [itemName, setItemName] = useState(\"\");\n    const [closestLocation, setClosestLocation] = useState(\"\");\n    const [recentLocation, setRecentLocation] = useState(\"\");\n    const [bestLocation, setBestLocation] = useState(\"\");\n    const [statusMessage, setStatusMessage] = useState(\"\");\n\n    let time = \"\";\n    let timeStatus = \"\";\n\n    //this runs the first time, and then again whenever username is changed \n    useEffect(() => {\n        timeStatus = \"\";\n        requestRecommendation();\n    }, [username])\n\n    // fetches the recommendation, might need to be async? doesn't look like it does at the moment\n    const fetchRecommendation = function(username, time, timeSlot, latitude, longitude) {\n        // for local testing use this:\n        // fetch(`http://localhost:8000/recommendation/`, {\n        // for testing the deployed hosting\n        fetch(`https://crewi-engine.herokuapp.com/recommendation/`, {\n            // GET can't take a request body, apparently\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            // request parameters for getting a recommendation\n            body: JSON.stringify({\n              username: username,\n              time: time,\n              timeSlot: timeSlot,\n              latitude: latitude,\n              longitude: longitude\n            })\n        })\n            .then(response => response.json())\n            .then(result => {\n                // logs the result, updates the state (which will update the DOM)\n                console.log(result);\n\n                // updating item info\n                setImgUrl(result.items[0].imgUrl);\n                setItemName(result.items[0].name);\n\n                // updating location info\n                setClosestLocation(result.locations.closestLocation);\n                setRecentLocation(result.locations.recentLocation);\n                setBestLocation(result.locations.bestLocation);\n\n                // determining the status message\n                determineStatus(result.statuses);\n\n                // going to the success screen\n                setStatus(\"success\");\n            }).catch(error => {\n                // logs the error, updates state to fail; this is the full engine failure, so there won't be a status array\n                console.log(error);\n                setStatus(\"fail\");\n            })\n    }\n\n    //our first attempt at loading in time; it works, but we should probably reformat the time a little\n    //if this fails, the exception will be caught in requestRec\n    const loadCurrentTime = function() {\n        // throw 'exception'\n        // I'd like to walk through this at some point to make sure edge cases are covered\n        // return date + \" \" + localTime;\n        Number.prototype.padLeft = function(base,chr){\n            var  len = (String(base || 10).length - String(this).length)+1;\n            return len > 0? new Array(len).join(chr || '0')+this : this;\n        }\n        //returns the date in YYYY-MM-DD HH:MM:SS format\n        var d = new Date(),\n        dformat = [d.getFullYear(),\n                (d.getMonth()+1).padLeft(),\n               d.getDate().padLeft()].join('-') +' ' +\n              [d.getHours().padLeft(),\n               d.getMinutes().padLeft(),\n               d.getSeconds().padLeft()].join(':');\n        return dformat;\n    }\n\n    // gets coordinates then finds the address from there; \"location\" is the address we need for the request\n    const loadCurrentLocation = async function() {\n        try {\n            // result will be a Geolocation object; await means execution will pause here until finished\n            let result = await getCoordinates();   \n\n            // returns the coordinates to requestRecommendation, takes in coordinates and options\n            return [result.coords.latitude, result.coords.longitude]\n        } catch {\n            setStatus(\"no-location loading\");\n            return [\"BLOCKED\", \"BLOCKED\"];\n        }\n    }\n\n    // returns current latitude and longitude\n    const getCoordinates = async function() {\n        // gets the current coordinates using geolocator\n        const coordinatePromise = new Promise((resolve, reject) => {\n            navigator.geolocation.getCurrentPosition(resolve, reject);\n        });\n        \n        // returns coords once the promise is resolved/rejected, which happens when geolocating is complete\n        return await coordinatePromise;\n    }\n\n    //this runs whenever state or props are updated; it updates token so that the useEffect above will run\n    //props are updated when the button is clicked bc it will update the main state, etc.\n    useEffect(() => {\n      domElement.getAttribute(\"data-subreddit\")\n        setUsername(domElement.getAttribute(\"username\"));\n        setOrderLink(domElement.getAttribute(\"orderLink\"));\n    })\n\n    // runs whenever radio buttons are clicked\n    const onValueChange = (event) => {\n        // updates time slot, re-renders so the buttons will actually be checked\n        setTimeSlot(event.target.value);\n    }\n\n    // runs when submitting time slot\n    const formSubmit = (event) => {\n        // prevents redirect on form submit\n        event.preventDefault();\n        // only proceed if the user actually picks a time slot; otherwise, just ignore the submit until they do\n        if (timeSlot != \"\") {\n            timeStatus = \"time slot selected\";\n            // because the requesting useEffect only runs on username change, request has to be called again\n            requestRecommendation();\n        }\n    }\n\n    // contains overarching logic for loading data, requesting recommendation, and updating status accordingly\n    const requestRecommendation = async function() {\n        // requesting is when the widget is \"loading\"\n        setStatus(\"loading\");\n\n        // reset statuses whenever reloading widget; these should be overwritten anyway\n        setStatusMessage(\"\");\n\n        // if time slot is blank, try to request with time loading\n        if (timeStatus == \"\") {\n            try {\n                // if this fails, no time is invoked\n                time = loadCurrentTime();\n\n                try {\n                    // grabs location (meaning street address) and waits here so that fetchRec won't get called until this done\n                    // loadCurrentLocation needs to return a blank or sentinel value into location if something fails\n                    let coordinates = await loadCurrentLocation();\n                    const latitude = coordinates[0];\n                    const longitude = coordinates[1];\n\n                    // this will actually grab the rec and update the status for the DOM\n                    fetchRecommendation(username, time, timeSlot, latitude, longitude);\n                \n                } catch (error) {\n                    console.log(error);\n                    // if something goes wrong, go into no-time mode (again, restructure this later)\n                    setStatus(\"fail\");\n                }\n            } catch (error) {\n                // if time loading failed, update status and don't continue the request\n                console.error(error);\n                setTimeSlot(\"\");\n                setStatus(\"no-time\");\n            }\n        } else {\n            // this will run if time failed and the user picked a time slot\n            try {\n                // grabs location (meaning street address) and waits here so that fetchRec won't get called until this done\n                // loadCurrentLocation needs to return a blank or sentinel value into location if something fails\n                let coordinates = await loadCurrentLocation();\n                const latitude = coordinates[0];\n                const longitude = coordinates[1];\n\n                // this will actually grab the rec and update the status for the DOM\n                fetchRecommendation(username, time, timeSlot, latitude, longitude);\n            } catch (error) {\n                console.log(error);\n                // if something goes wrong, display fail\n                setStatus(\"fail\");\n            }\n        }\n\n        // time slot needs to be reset after each request so that loading time will be re-attempted\n        \n    }\n\n    const clickOrder = () =>{\n        window.location.href = orderLink;\n    }\n\n    const copyLocation = location => {\n        navigator.clipboard.writeText(location);\n    }\n\n    const showBest = () => {\n        // Get the snackbar DIV\n        var x = document.getElementById(\"bestSnackbar\");\n\n        document.getElementById(\"bestButton\").disabled = true;\n\n        // Add the \"show\" class to DIV\n        x.className += \"show\";\n\n        // After 3 seconds, remove the show class from DIV\n        setTimeout(function(){\n            x.className = x.className.replace(\"show\", \"\"); \n            document.getElementById(\"bestButton\").disabled = false;\n        }, 3000);\n    }\n\n    const showClosest = () => {\n        // Get the snackbar DIV\n        var x = document.getElementById(\"closestSnackbar\");\n\n        document.getElementById(\"closestButton\").disabled = true;\n\n        // Add the \"show\" class to DIV\n        x.className += \"show\";\n\n        // After 3 seconds, remove the show class from DIV\n        setTimeout(function(){\n            x.className = x.className.replace(\"show\", \"\"); \n            document.getElementById(\"closestButton\").disabled = false;\n        }, 3000);\n    }\n\n    const showRecent = () => {\n        // Get the snackbar DIV\n        var x = document.getElementById(\"recentSnackbar\");\n\n        document.getElementById(\"recentButton\").disabled = true;\n\n        // Add the \"show\" class to DIV\n        x.className += \"show\";\n\n        // After 3 seconds, remove the show class from DIV\n        setTimeout(function(){\n            x.className = x.className.replace(\"show\", \"\"); \n            document.getElementById(\"recentButton\").disabled = false;\n        }, 3000);\n    }\n\n    const showStatus = () => {\n        // Get the snackbar DIV\n        var x = document.getElementById(\"statusSnackbar\");\n\n        document.getElementById(\"statusBtn\").disabled = true;\n\n        // Add the \"show\" class to DIV\n        x.className += \"show\";\n\n        // After 3 seconds, remove the show class from DIV\n        setTimeout(function(){\n            x.className = x.className.replace(\"show\", \"\"); \n            document.getElementById(\"statusBtn\").disabled = false;\n        }, 3000);        \n    }\n\n    // this method determines what message to display to the end user based on the engine's issues and fails\n    // lots of room for adjustment here, refer to documentation\n    const determineStatus = (statusArray) => {\n        // msg is defaulted to blank, if there isn't a global fail, bad username, or location fail, it'll stay blank\n        // the other fails/issues aren't of top priority, so this keeps the user messages limited\n        // the response can still be logged to see all statuses if needed for debugging\n        let msg = \"\";\n        \n        // global fail takes priority, it means everything failed and the default is being used\n        // then bad username (if one was given), then location services being blocked\n        // could easily add a scenario for bad username and bad location, but that's probably less useful\n        // in theory if both are broken the user will just fix them one at a time\n        // plenty of adjustments could be made, can document and revise as needed\n        if (statusArray.includes(\"GLOBAL_FAIL\")) {\n            msg = \"Unable to make a customized recommendation at this time...\";\n        } else if (statusArray.includes(\"BAD_USERNAME_ISSUE\") && username) {\n            msg = \"No user found with that username, try signing in again\";\n        } else if (statusArray.includes(\"RECOMMEND_CLOSEST_ISSUE\")) {\n            msg = \"We couldn't find you, double check location permissions\";\n        }\n\n        setStatusMessage(msg);\n    }\n\n    // DISPLAY SECTION\n\n    // loading display\n    if (status == \"loading\")\n    {\n        return(\n            <div className='widgetLoading widgetBox boxShadowImitation' style={{\n                backgroundImage: `url(https://drive.google.com/uc?export=view&id=1jOKIa9urkCFsa6OGGf8Hrd8DROPzkmfa)`\n            }}>\n            </div>        \n        )\n    }\n\n    else if (status == \"no-location loading\")\n    {\n        return(\n            <div className='widgetLoading widgetBox boxShadowImitation' style={{\n                backgroundImage: `url(https://drive.google.com/uc?export=view&id=1jOKIa9urkCFsa6OGGf8Hrd8DROPzkmfa)`\n            }}>\n                <span className='widgetText'>\n                    Location unavailable\n                </span>\n            </div>\n        )\n    }\n\n    // no-time display\n\n    else if (status == \"no-time\")\n    {\n        //I think here we would want to display username if the end user has enetered it\n        return(\n            <div className='widgetBox boxShadowImitation' style={{\n                backgroundImage: `none`}}>\n                \n                <span>Unable to load time, please select an option below:</span>\n                <hr />\n                <br />\n                <form onSubmit={formSubmit}>\n                    <div style={{ paddingLeft: '38%', textAlign: \"left\"}}>\n                            <div className=\"radio\">\n                                <label>\n                                    <input\n                                        type=\"radio\"\n                                        value=\"Morning\"\n                                        name=\"dayPart\"\n                                        checked={timeSlot == \"Morning\"} \n                                        onChange={onValueChange}\n                                    />&nbsp;\n                                    Morning\n                                </label>\n                            </div>\n                            <div className=\"radio\">\n                                <label>\n                                    <input\n                                        type=\"radio\"\n                                        value=\"Afternoon\" \n                                        name=\"dayPart\"\n                                        checked={timeSlot == \"Afternoon\"} \n                                        onChange={onValueChange}\n                                    />&nbsp;\n                                    Afternoon\n                                </label>\n                            </div>\n                            <div className=\"radio\">\n                                <label>\n                                    <input\n                                        type=\"radio\"\n                                        value=\"Night\"\n                                        name=\"dayPart\"\n                                        checked={timeSlot == \"Night\"}\n                                        onChange={onValueChange}\n                                    />&nbsp;\n                                    Night\n                                </label>\n                            </div>\n                        </div>\n                            <br/>\n                            <button type=\"submit\" className='widgetButton'>Submit</button>\n                        </form>                \n            </div>\n        )\n    }\n\n    // success display (if rec is loaded successfully)\n\n    else if (status == \"success\")\n    {\n        // location for showing status\n        let statusHtml;\n        if (statusMessage) {\n            statusHtml = (<div>\n                <button className='widgetButton statusButton' id=\"statusBtn\" onClick={showStatus}>&nbsp;!&nbsp;</button>\n                <div className=\"snackbar \" id=\"statusSnackbar\">{statusMessage}</div>\n            </div>\n            )\n        }\n\n\n        // logic for handling the location display; swap out the specific HTML as needed\n        // also there's gotta be a better way to do this logic\n        let locationHtml;\n        \n        if (bestLocation) {\n            // if there's a best location, show it (means closest and most recent were the same and not blank)\n            locationHtml = (<div>\n                <button className='widgetButton' id=\"bestButton\" onClick={showBest}>Best Location</button>\n                <div onClick={() => copyLocation(bestLocation)} className=\"snackbar \" id=\"bestSnackbar\">{bestLocation}</div>\n            </div>)\n        } else if (closestLocation && recentLocation) {\n            // if there isn't a best location (b/c of the 'else') but closest and recent are truthy, they must be different (show both)\n            locationHtml = (<div>\n                <button className='widgetButton' id=\"closestButton\" onClick={showClosest}>Closest Location</button>\n                <div onClick={() => copyLocation(closestLocation)} className=\"snackbar \" id=\"closestSnackbar\">{closestLocation}</div>\n                &nbsp;\n                <button className='widgetButton' id=\"recentButton\" onClick={showRecent}>Previous Location</button>\n                <div onClick={() => copyLocation(recentLocation)} className=\"snackbar \" id=\"recentSnackbar\">{recentLocation}</div>\n            </div>)\n        } else if (closestLocation) {\n            // this happens if closest and recent were different, but recent was falsy, meaning it was blank (show closest only)\n            locationHtml = (<div>\n                <button className='widgetButton' id=\"closestButton\" onClick={showClosest}>Closest Location</button>\n                <div onClick={() => copyLocation(closestLocation)} className=\"snackbar \" id=\"closestSnackbar\">{closestLocation}</div>\n            </div>)\n        } else if (recentLocation) {\n            // this happens if closest and recent were different, but closest was falsy, meaning it was blank (show recent only)\n            locationHtml = (<div>\n                <button className='widgetButton' id=\"recentButton\" onClick={showRecent}>Previous Location</button>\n                <div onClick={() => copyLocation(recentLocation)} className=\"snackbar \" id=\"recentSnackbar\">{recentLocation}</div>\n            </div>)\n        } else {\n            // this means best, recent, and closest locations were all falsy (very likely blank); show an error or something, probably a reset button too\n            // may want to change this later, but the most elegant solution might just be to show nothing\n            // locationHtml = (<div>\n            //     {/* <span className='widgetText'>\n            //         LOCATION SERVICES FAILED\n            //     </span> */}\n            // </div>)\n        }\n\n        return(\n            <div id=\"widget\" className='widgetBox boxShadowImitation' style={{\n                backgroundImage: `url(${imgUrl})`\n            }}>\n                <button className='widgetButton resetButton' onClick={requestRecommendation}>&#8635;</button>\n                <span className='widgetText'>\n                    {itemName}\n                </span>\n                <br/>\n                <br/>\n                {statusHtml}\n                {locationHtml}\n                <br/>\n                <br/>\n            <button onClick={clickOrder} className='widgetButton' id=\"orderSpan\">Order Now</button>\n            </div>\n        )\n    }\n\n    // fail display (if rec fails completely)\n\n    else if (status == \"fail\")\n    {\n        return(\n            <div className='widgetBox boxShadowImitation' style={{\n                backgroundImage: `none`}}>\n                <span className='widgetText'>\n                    Recommendation failed\n                </span>\n                <br/>\n                <br/>\n                <br/>\n                <br/>\n                <button className='widgetButton' style={{\n                    //   background: '#a83232'\n                }} onClick={requestRecommendation}>Retry</button>\n            </div>\n        )\n    }\n\n    // may want to add more nuances, like having messages for showing location/time failure on the success display or something\n\n  \n \n}\n\nexport default App;\n","C:\\Users\\sward22\\Desktop\\Capstone_CREWI\\client\\crewi-widget\\src\\reportWebVitals.js",[],[],{"ruleId":"33","severity":1,"message":"34","line":5,"column":10,"nodeType":"35","messageId":"36","endLine":5,"endColumn":20},{"ruleId":"33","severity":1,"message":"37","line":20,"column":10,"nodeType":"35","messageId":"36","endLine":20,"endColumn":25},{"ruleId":"38","severity":1,"message":"39","line":42,"column":22,"nodeType":"40","endLine":42,"endColumn":24},{"ruleId":"41","severity":1,"message":"42","line":98,"column":9,"nodeType":"43","messageId":"44","endLine":101,"endColumn":10},{"ruleId":"38","severity":1,"message":"45","line":140,"column":5,"nodeType":"35","endLine":140,"endColumn":14,"suggestions":"46"},{"ruleId":"47","severity":1,"message":"48","line":157,"column":22,"nodeType":"49","messageId":"44","endLine":157,"endColumn":24},{"ruleId":"47","severity":1,"message":"50","line":173,"column":24,"nodeType":"49","messageId":"44","endLine":173,"endColumn":26},{"ruleId":"47","severity":1,"message":"50","line":320,"column":16,"nodeType":"49","messageId":"44","endLine":320,"endColumn":18},{"ruleId":"47","severity":1,"message":"50","line":330,"column":21,"nodeType":"49","messageId":"44","endLine":330,"endColumn":23},{"ruleId":"47","severity":1,"message":"50","line":345,"column":21,"nodeType":"49","messageId":"44","endLine":345,"endColumn":23},{"ruleId":"47","severity":1,"message":"50","line":363,"column":59,"nodeType":"49","messageId":"44","endLine":363,"endColumn":61},{"ruleId":"47","severity":1,"message":"50","line":375,"column":59,"nodeType":"49","messageId":"44","endLine":375,"endColumn":61},{"ruleId":"47","severity":1,"message":"50","line":387,"column":59,"nodeType":"49","messageId":"44","endLine":387,"endColumn":61},{"ruleId":"47","severity":1,"message":"50","line":403,"column":21,"nodeType":"49","messageId":"44","endLine":403,"endColumn":23},{"ruleId":"47","severity":1,"message":"50","line":478,"column":21,"nodeType":"49","messageId":"44","endLine":478,"endColumn":23},"no-unused-vars","'renderPost' is defined but never used.","Identifier","unusedVar","'nonStickiedOnly' is defined but never used.","react-hooks/exhaustive-deps","Assignments to the 'timeStatus' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","Literal","no-extend-native","Number prototype is read only, properties should not be added.","AssignmentExpression","unexpected","React Hook useEffect contains a call to 'setUsername'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [domElement] as a second argument to the useEffect Hook.",["51"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","Expected '===' and instead saw '=='.",{"desc":"52","fix":"53"},"Add dependencies array: [domElement]",{"range":"54","text":"55"},[5926,5926],", [domElement]"]